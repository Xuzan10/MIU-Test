package com.sujan.practice;

import org.junit.Test;


import static org.junit.Assert.assertEquals;

public class TestSet3 {

    @Test
    public void countSquarePairTest() {
        assertEquals(3, countSquarePair(new int[]{11, 5, 4, 20}));
        assertEquals(2, countSquarePair(new int[]{9, 0, 2, -5, 7}));
        assertEquals(0, countSquarePair(new int[]{9}));

    }

    /*
    Define a square pair to be the tuple <x, y> where x and y are positive, non-zero integers, x<y and x + y is a perfect square. A perfect square is an integer whose square root is also an integer, e.g. 4, 9, 16 are perfect squares but 3, 10 and 17 are not. Write a function named countSquarePairs that takes an array and returns the number of square pairs that can be constructed from the elements in the array. For example, if the array is {11, 5, 4, 20} the function would return 3 because the only square pairs that can be constructed from those numbers are <5, 11>, <5, 20> and <4, 5>
    * */
    public int countSquarePair(int[] a) {
        if (a.length < 2) {
            return 0;
        }

        int count = 0;
        for (int first : a) {
            for (int second : a) {
                if (first > 0 && second > 0 && first < second) {
                    int sum = first + second;
                    double square = Math.sqrt(sum);
                    if (square % 1 == 0) {
                        count++;
                    }
                }
            }

        }
        System.out.println("Count square pair is " + count);
        return count;
    }


    @Test
    public void findPorcupineNumberTest() {
        assertEquals(139, findPorcupineNumber(0));
        assertEquals(139, findPorcupineNumber(138));
        assertEquals(409, findPorcupineNumber(139));
    }


    /*
    . A prime number is an integer that is divisible only by 1 and itself. A porcupine number is a prime number whose last digit is 9 and the next prime number that follows it also ends with the digit 9. For example 139 is a porcupine number because:
    a. it is prime
    b. it ends in a 9
    c. The next prime number after it is 149 which also ends in 9. Note that 140, 141, 142, 143, 144, 145, 146, 147 and 148 are not prime so 149 is the next prime number after 139.

    * */
    public int findPorcupineNumber(int n) {

        int num = n + 1;

        while (true) {
            boolean numIsPrime = Helper.isNumberPrime(num);
            int nextPrime = Helper.nextPrimeNumber(num);
            if (numIsPrime && num % 10 == 9 && nextPrime % 10 == 9) {
                break;
            }
            num++;
        }
        return num;
    }


    /*
    . Consider the following algorithm
	Start with a positive number n
	if n is even then divide by 2
	if n is odd then multiply by 3 and add 1
	continue this until n becomes 1

    The Guthrie sequence of a positive number n is defined to be the numbers generated by the above algorithm.

    * */

    @Test
    public void isGuthrieSequenceTest() {
        assertEquals(1, isGuthrieSequence(new int[]{7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1}));
        assertEquals(1, isGuthrieSequence(new int[]{8, 4, 2, 1}));
        assertEquals(0, isGuthrieSequence(new int[]{8, 17, 4, 1}));
        assertEquals(0, isGuthrieSequence(new int[]{8, 4, 1}));
        assertEquals(0, isGuthrieSequence(new int[]{8, 4, 2}));
    }

    public int isGuthrieSequence(int[] a) {
        if (a[a.length - 1] != 1)
            return 0;


        for (int i = 0; i < a.length - 1; i++) {
            int nextValue;
            int num = a[i];
            int next = a[i + 1];

            if (num % 2 == 0) {
                nextValue = num / 2;
            } else {
                nextValue = num * 3 + 1;
            }
            if (next != nextValue)
                return 0;
        }

        return 1;
    }

}
